<!-- ui/matrix_rain.html -->
<!doctype html>
<html>
<head>
<meta charset="utf-8"/>
<style>
  :root{
    /* visual tuning */
    --alpha: 0.08;         /* trail strength (lower = longer trails) */
    --bg1: #0b1220;
    --bg2: #070b14;

    /* baseline font size; layers scale from this */
    --font-base: 18;       /* px */

    /* per-layer speed (lower = slower) */
    --speed-back:  42;     /* ms per step */
    --speed-mid:   28;
    --speed-front: 18;

    /* glow softness */
    --glow: 4;             /* px; keep small to avoid blur */
  }

  html,body{margin:0;padding:0;height:0}
  #neoCanvas{
    position:fixed;inset:0;z-index:-1;pointer-events:none;
    background: radial-gradient(1200px 800px at 8% 12%, var(--bg1) 0%, var(--bg2) 60%, #05070d 100%);
  }
</style>
</head>
<body>
<canvas id="neoCanvas"></canvas>
<script>
/*
  NeoGlyph Rain — layered, no strobe, crisp, slower motion.
  - 3 parallax layers (back/mid/front) with different font sizes & speeds
  - subtle per-column color variance (no global strobing)
  - easy glyph override: set window.NEO_GLYPHS = "…"
*/

(() => {
  const canvas = document.getElementById('neoCanvas');
  const ctx = canvas.getContext('2d');

  // --- glyph set (override by defining window.NEO_GLYPHS) ---
  const fallback = "Δ◉◆○⬣⬢◇✧✦✼✺✹✸✷⚚⚝⚘☼☯⌁⌇⌘⌬⌖⌗⟡⟠⟣⟟⟜░▒▓█▚▞▩▣▧▤▥▦▨▯▮▭▰▱";
  const glyphs = (window.NEO_GLYPHS || fallback).split("");

  // palette: fixed cool neon set, no time-based cycling
  const palette = [
    "#00f5d4","#00e5ff","#6e7bff","#b07aff",
    "#ff59cf","#ff7a6b","#ffd166","#a0ff6a"
  ];

  // util
  const cssNum = (v, d=0) => {
    const n = parseFloat(getComputedStyle(document.documentElement).getPropertyValue(v));
    return isNaN(n) ? d : n;
  };

  let W=0, H=0;
  function resize(){
    W = canvas.width  = window.innerWidth;
    H = canvas.height = window.innerHeight;
    layers.forEach(L => L.init());
  }
  window.addEventListener('resize', resize);

  // Layer factory
  function makeLayer(opts){
    const L = {
      name: opts.name,
      fontScale: opts.fontScale,       // relative to --font-base
      stepMs: opts.stepMs,             // ms per vertical step
      shade: opts.shade,               // 0..1 mixes palette → subtle variance
      cols: 0,
      size: 0,                          // px
      drops: [],
      tacc: 0,
      init(){
        const base = cssNum('--font-base', 18);
        this.size = Math.max(12, Math.round(base * this.fontScale));
        ctx.font = `${this.size}px monospace`;
        this.cols = Math.max(1, Math.floor(W / this.size));
        // each column starts at random row
        this.drops = new Array(this.cols).fill(0).map(()=>Math.floor(Math.random()*Math.ceil(H/this.size)));
        // precompute colors per column (no strobe)
        this.colColor = new Array(this.cols).fill(0).map((_,i)=>{
          const c = palette[i % palette.length];
          // slightly mix with neighbor color for variation
          const mix = palette[(i+3) % palette.length];
          const ratio = 0.15 + this.shade * 0.25;
          return lerpColor(c, mix, ratio);
        });
      },
      step(dt){
        this.tacc += dt;
        if(this.tacc < this.stepMs) return;   // control speed
        this.tacc = 0;

        // trail
        ctx.fillStyle = `rgba(0,0,0,${cssNum('--alpha',0.08)})`;
        ctx.fillRect(0,0,W,H);

        // draw each column
        ctx.shadowBlur = cssNum('--glow',4);

        for(let i=0;i<this.cols;i++){
          const x = i * this.size;
          const y = this.drops[i] * this.size;

          ctx.shadowColor = this.colColor[i];
          ctx.fillStyle   = this.colColor[i];

          const g = glyphs[(Math.random()*glyphs.length)|0];
          ctx.font = `${this.size}px monospace`;
          ctx.fillText(g, x, y);

          // reset drop with gentle randomness
          if(y > H && Math.random() > 0.975) this.drops[i] = 0;
          this.drops[i]++; // advance one row
        }
      }
    };
    return L;
  }

  // Color lerp in sRGB
  function lerpColor(a,b,t){
    const pa = hexToRgb(a), pb = hexToRgb(b);
    const r = Math.round(pa.r + (pb.r - pa.r) * t);
    const g = Math.round(pa.g + (pb.g - pa.g) * t);
    const b2= Math.round(pa.b + (pb.b - pa.b) * t);
    return `rgb(${r},${g},${b2})`;
  }
  function hexToRgb(h){
    const s = h.replace('#','');
    const n = s.length===3 ? s.split('').map(c=>c+c).join('') : s;
    return { r:parseInt(n.slice(0,2),16), g:parseInt(n.slice(2,4),16), b:parseInt(n.slice(4,6),16) };
  }

  // Three layers: background slow/big, mid medium, front fastest/smallest
  const layers = [
    makeLayer({ name:'back',  fontScale:1.4, stepMs: cssNum('--speed-back',42),  shade: 0.10 }),
    makeLayer({ name:'mid',   fontScale:1.0, stepMs: cssNum('--speed-mid',28),   shade: 0.25 }),
    makeLayer({ name:'front', fontScale:0.78,stepMs: cssNum('--speed-front',18), shade: 0.40 })
  ];

  resize();

  // animation loop with proper delta timing
  let last = performance.now();
  function frame(now){
    const dt = now - last; last = now;
    // we do one clear per frame for all layers (trail controlled by alpha)
    // (already handled inside step to keep trails layer-consistent)
    layers.forEach(L => L.step(dt));
    requestAnimationFrame(frame);
  }
  requestAnimationFrame(frame);
})();
</script>
</body>
</html>
